---
title: "Dataframe manipulation with R"
date: "`r Sys.Date()`"
author:
  - name: "BiGR: Bioinformatics core facility of Gustave Roussy"
email: "bigr@gustaveroussy.fr"
output:
  rmdformatsbigr::readthebigrdoc:  # if you'd like to have a nice theme
  code_folding: show
thumbnails: false
lightbox: true
highlight: true
fig_caption: false

# install.packages("remotes")
# install.packages("git2r")
# remotes::install_git("https://gitlab.com/bioinfo_gustaveroussy/bigr/rmdformatsbigr.git",
#                      credentials=git2r::cred_user_pass("your_login", "your_password"))
---

```{r setup, include=FALSE, eval=FALSE}
# options(width = 60);
knitr::opts_chunk$set(
  echo = TRUE,        # Print the code
  eval = TRUE,        # Run command lines
  message = TRUE,     # Print messages
  prompt = FALSE,     # Do not display prompt
  comment = NA,       # No comments on this section
  warning = TRUE      # Display warnings
)

```
<style type="text/css">
summary {
  display: list-item;
}
details:hover {
  cursor: pointer
}
body {
  text-align: justify
}
.column-left{
  float: left;
  width: 47%;
  text-align: left;
}
.column-right{
  float: right;
  width: 47%;
  text-align: left;
}
</style>

# Purpose

At the end of this session, you will be able to:

1. Create a dataframe
1. Display basic characteristics on a dataframe
1. Select values in a dataframe
1. Filter a dataframe
1. Replace elements in a dataframe
1. Merge 2 dataframes
1. Make operations on a dataframe


# Basic reminders

## Dataframes

### Definition
A data table, or data.frame, has several rows (also called observations) and columns (also called variables). The columns of a data table can be of different types, and are named. Within a column, all values must be of the same type.

### Creation

A dataframe can be created using the [`data.frame()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame) function, from 2 previously defined vectors:

```{r}
vector1 <- c(1:10)
vector2 <- c(2:11)

my_df <- base::data.frame(my_col1 = vector1, my_col2 = vector2)
my_df
```


*Question 1* : What happens if we forget to give column names?

```{r, eval = FALSE}
my_df <- base::data.frame(vector1, vector2)
```

<details>

<summary>Answer</summary>

```{r}
my_df <- base::data.frame(vector1, vector2)
my_df
```

The created data frame will have as column names the names of the vectors used for each column.

</details>
<br>


*Question 2* : What if we don't name the vectors either?

```{r, eval = FALSE}
my_df <- base::data.frame(c(1:10), c(2:11))
```
<details>

<summary>Answer</summary>
```{r}
my_df <- base::data.frame(c(1:10), c(2:11))
my_df
```
R will automatically generate a column name for you.
However, we recommend always giving your columns a name and never letting R do it alone. Indeed, this can sometimes produce very particular long or strange names.

</details>
<br>


To check the names of our columns, we can display them with the [`colnames()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/row%2Bcolnames) function.
```{r}
base::colnames(my_df)
```

*Question* : How can we rename all columns of a data.frame?

<details>
<summary>Answer</summary>
```{r}
base::colnames(my_df) <- c("new_col1", "newcol_2")
my_df
```
</details>
<br>

In some cases we may need an empty dataframe that we will fill later:
```{r}
my_empty_df <- base::data.frame(Genes_name = character(),
                                Expression = integer(),
                                Normalized_Expression = double(),
                                Over_expressed_Gene = logical())
my_empty_df
```
In the previous example, a name and a type are assigned to each column.
And this dataframe contains 0 rows.

### Observation of our data

For the rest of the course, we will use the Clinical_Cohort.csv table which you can find here https://github.com/gustaveroussy/training_bigr/blob/main/Tables_manipulation/For_Students/Clinical_Cohort.csv.
```{r}
clinical_data <- utils::read.table("Clinical_Cohort.csv", sep = ",", header = TRUE)
```

As every time you load a table for the first time in R, you have to look at what it looks like.
For that, R provides a whole set of very useful functions.

The [`head()`](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/head) function displays the first rows of the table. We can specify the number of lines to display with the `n` argument.

```{r}
# display of first lines (6 by default)
utils::head(clinical_data)
# display of 10 first lines
utils::head(clinical_data, n = 10)
```

Likewise, we can display the last rows of the table using the [`tail()`](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/head) function.
```{r}
# display last lines
utils::tail(clinical_data)
# display 10 last lines
utils::tail(clinical_data, n = 10)
```

You can also display the number of rows in the table with the [`nrow()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/nrow) function, the number of columns with the [`ncol()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/nrow) function, or both at the same time with the [`dim()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/dim) function.
```{r}
# number of lines
base::nrow(clinical_data)
# number of columns
base::ncol(clinical_data)
# table dimensions
base::dim(clinical_data)
```

We can check the class of our table with the [`class()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/class) function as well as its structure with the [`str()`](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/str) function.

```{r}
base::class(clinical_data)
utils::str(clinical_data)
```

As seen previously, we can display column names with the [`colnames()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/row%2Bcolnames) function, but we can also display row names with the [`rownames()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/row%2Bcolnames) function.

```{r}
base::colnames(clinical_data)
base::rownames(clinical_data)
```
These functions also allow you to rename columns and rows.
However, it is quite rare that we name the rows of a data table. Indeed, the names must be unique, so all the information of interest is stored directly in the table.

Also if your table is not the "right" way you can transpose the table (i.e. reverse the rows and columns) using the [`t()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/t) function.

```{r}
base::t(clinical_data)
```

We can obtain a simple statistical summary of the data with the [`summary()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary) function:

```{r}
base::summary(clinical_data)
```


### Positive selection of elements
You can access a column and a line in the data frame using an index for each dimension into squared brackets `[` and `]`. 

R expects first an index for rows, then columns : `data_frame[row_index, column_index]`. You can either use the name of row(s)/column(s) or their position index.

If one wants all values for one of the dimensions, one should just leave the bracket part empty.
```{r}
# select a row by its name (remember here rows are names "1","2","3" etc)
clinical_data["2", ]
# select a row by its index
clinical_data[1, ]
# select a column by its name
clinical_data[, "Age"]
# select a column by its index
clinical_data[, 1]
# select a cell
clinical_data["1", "Subject_number"]
# select the 1st two rows of the 1st column
clinical_data[1:2, 1]
# select the 1st and the 3rd rows, of the 1st and the 4th to the 7th columns
clinical_data[c(1,3), c(1,4:7)]
# select several columns by their name
clinical_data[, c("Subject_number","NSCLC_type")]
```

You can also access an entire column with the `$` followed by the name of the column to select:
```{r}
clinical_data$Subject_number
```

Or with a double squared bracket:
```{r}
clinical_data[["Subject_number"]]
clinical_data[[1]]
```

So to sum up, there are 3 ways to select a column: `clinical_data[,"Subject_number"]`, `clinical_data$Subject_number`, `clinical_data[["Subject_number"]]`.

*Question* : If we select part of a dataframe, what is the type of a selection?

<details>
<summary>Answer</summary>

If multiple columns -> data frame.  
If only one column -> the type of the column elements.  
if only one element -> the type of the element (which correspond to the type of its column).  

</details>
<br>


We can only display the first values of a column with the [`head()`](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/head) function, but we give it the values of the column as arguments:
```{r}
# display the 10 first values of the Age column
utils::head(clinical_data$Age,10)
```

Likewise, you can display simple statistics on a numeric column with the functions [`min()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/Extremes), [`max()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/Extremes), [`mean()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/mean), [`median()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/median), etc.
```{r}
base::min(clinical_data$Age)
base::max(clinical_data$Age)
base::mean(clinical_data$Age)
stats::median(clinical_data$Age)
base::length(clinical_data$Age)
```

The [`table()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) function allows to get the occurrence of each value of a vector (here a column of a dataframe):
```{r}
base::table(clinical_data$NSCLC_type)
```
Here we have 5 (lines of the dataframe) patients with an adenocarcinoma, 2 (lines of the dataframe) patients with a large cell carcinoma, and 4 (lines of the dataframe) patients with a squamous cell carcinoma.

We can also use the [`subset()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset) function, which allows you to make column selections from column names:

```{r}
base::subset(clinical_data, select = Age)
base::subset(clinical_data, select = c(Subject_number, Age))
```
Be careful, you don't write quotes around column names with subset().


*Question* : If we select part of a dataframe, what is the type of this selection?

<details>
<summary>Answer</summary>

If multiple columns -> data frame.  
If only one column -> data frame too!  
If only one element -> impossible to select only one element easily with [`subset()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset).

</details>
<br>

### Negative selection of elements

We have just seen how to select certain information of interest in our table. But what if all the information is important except one.

To remove an entire column, simply set the column to NULL:
```{r}
# remove the Comments column
clinical_data$Comments <- NULL
clinical_data

# delete the second column (Sex)
clinical_data[,2] <- NULL
clinical_data
```

You can also select all columns except one, by placing a `-` in front of the column index:
```{r}
# take all values except those of the second column
clinical_data[,-2]

# take all values except those of the second column to the fourth column
clinical_data[,-2:-4]

# take all values except those of the second column and the third column
clinical_data[,-c(2,3)]
clinical_data[,c(-2,-3)] #same

```

*Question* : 

Does it work with column names like for selection?
```{r, eval = FALSE}
clinical_data[,-"Subject_number"]
clinical_data[,-c("Subject_number","Age")]
```
<details>
<summary>Answer</summary>

No it doesn't work like that. We will see later how can we do that (we need logicals).

</details>
<br>

We can also use the [`subset()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset) function:
```{r}
base::subset(clinical_data, select = -Age)
base::subset(clinical_data, select = -c(Subject_number, Age))

```
Still no quotes around column names with [`subset()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset).


## Logicals

### Definition

Logical vectors can contain the values `TRUE`, `FALSE`, and `NA` (for "not available"). These values are generated as the result of logical "conditions".
We can create conditions using certain mathematical operators called logical operators: `>`, `<`,  `>=`, `<=`, `==` (for exact equality) and `!=` (for inequality). These operators allow you to ask a question to which you must answer True or False.

```{r}
5 > 1
```
To the question is 5 greater than 1, R told us that yes this statement is `TRUE`.

If we emit a condition on a vector:
```{r}
num_vect <- c(0.5, 55, -10, 6)
num_vect < 1
```
R answers us on each element of the vector. The first element of num_vect is 0.5, which is less than 1 and therefore the statement 0.5 < 1 is `TRUE`. The second element of num_vect is 55, which is greater than 1, so the statement 55 < 1 is `FALSE`. The same logic applies for the third and fourth elements.

> Note:
> `==` is the convention in many computer programming languages in which the `=` (single equals sign) is the assignment operator. In R, `<-` is the assignment operator, `=` is used for arguments of functions, and `==` is the equals comparison operator.


### OR, AND and !
If we have two logical expressions, A and B, we can ask whether at least one is TRUE with `A | B` (logical **OR** a.k.a. **union**) or whether they are both TRUE with `A & B` (logical **AND** a.k.a. **intersection**).
```{r, eval = FALSE}
5 < 1 | 0 < 1 # FALSE | TRUE => TRUE
5 > 1 | 0 > 1 # TRUE | FALSE => TRUE
5 < 1 | 0 > 1 # FALSE | FALSE => FALSE
5 > 1 | 0 < 1 # TRUE | TRUE => TRUE

5 < 1 & 0 < 1 # FALSE & TRUE => FALSE
5 > 1 & 0 > 1 # TRUE & FALSE => FALSE
5 < 1 & 0 > 1 # FALSE & FALSE => FALSE
5 > 1 & 0 < 1 # TRUE & TRUE => TRUE
```

The `|` version of OR evaluates OR across an entire vector, while the `||` version of OR only evaluates one element. Same thing for the `&` and the `&&` operators.

```{r, eval = FALSE}
c(TRUE, FALSE, TRUE) | c(TRUE, FALSE, FALSE)  # TRUE FALSE TRUE
c(TRUE, FALSE, TRUE) || c(TRUE, FALSE, FALSE) # Error: 'length = 3' in coercion to 'logical(1)'
TRUE|| FALSE                                  # TRUE
c(TRUE, FALSE, TRUE) & c(TRUE, FALSE, FALSE)  # TRUE FALSE FALSE
c(TRUE, FALSE, TRUE) && c(TRUE, FALSE, FALSE) # Error: 'length = 3' in coercion to 'logical(1)'
TRUE && FALSE                                 # FALSE
```

`!A` is the negation of the expression A and is TRUE when A is FALSE and vice versa.

```{r, eval = FALSE}
5 < 1    # FALSE
!(5 < 1) # !FALSE => TRUE

```

Lastely, just like arithmetic, logical expressions can be grouped by parenthesis to define priorities.

### Training

*Question 1* : 

What is the result of this expression?

```{r, eval = FALSE}
(FALSE == TRUE) == FALSE
```

<details>
<summary>Answer</summary>
```{r}
(FALSE == TRUE) == FALSE
```
</details>
<br>

*Question 2* : 

What is the result of this expression?

```{r, eval = FALSE}
((111 >= 111) | !(TRUE)) & ((4 + 2) == 6)
```

<details>
<summary>Answer</summary>
```{r}
((111 >= 111) | !(TRUE)) & ((4 + 2) == 6) # (TRUE | FALSE) & (6 == 6) => (TRUE) & (TRUE) => TRUE
```
</details>
<br>


*Question 3* : 

What is the result of this expression?

```{r, eval = FALSE}
((-2:2) >= 0) & ((-2:2) <= 0)
```

<details>
<summary>Answer</summary>
```{r}
((-2:2) >= 0) & ((-2:2) <= 0)
```
```
Explanation:
```{r, eval =  FALSE}
(c(-2, -1, 0, 1, 2) >= 0)       & (c(-2,-1,0,1,2) <= 0)
(c(FALSE,FALSE,TRUE,TRUE,TRUE)) & (c(TRUE,TRUE,TRUE,FALSE,FALSE))
# => FALSE FALSE TRUE FALSE FALSE
```
</details>
<br>


*Funny Bonus Question* : 

What is the result of this weird expression?

```{r, eval = FALSE}
(TRUE + TRUE) * FALSE
```


<details>
<summary>Answer</summary>
```{r}
(TRUE + TRUE) * FALSE
```

0?! But it is `TRUE` and `FALSE`, why do we get a number now?!

This is linked to the history of computing languages.
Prior to the introduction of an actual boolean type (`TRUE` and `FALSE`), the integers `0` and `1` were the official representation for true and false values, similar to what is used in C-89 (the first standardized version of the C programming language, in 1989).  
To avoid unnecessarily breaking imperfect but working code, the new boolean type needed to work just like 0s and 1s. This goes beyond merely truth value, but all integral operations. No one would recommend using a boolean results in a numeric context, nor would most people recommend testing equality to determine truth value, as well as no one wanted to find out the hard way just how much existing code is that way. Thus, the decision to make True and False mimics for 1 and 0, respectively. This is merely a historical artifact of the linguistic evolution.

</details>
<br>


# Conditional selection

The key idea is that we use some criteria (conditions) to extract a subset of rows from our data and use only those rows in subsequent analysis.

What is the link with logical operators?
Here we will use conditions to select interesting rows. For example, selecting row where there is the value "A" in the first column. So R will test each line of the first column to know if the value is "A" (return `TRUE`) or not (return `FALSE`), then only keep line with `TRUE`.

There are three ways to subset data in R:  
- Use R’s built in data manipulation tools. These are easily identified by their square bracket `[]` syntax.  
- Use R’s built in data manipulation functions: [`subset()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset).  
- Use the [`dplyr`](https://dplyr.tidyverse.org/) R package.  

## R base

### Filter for Rows Based on one Condition

#### Filter for Rows Based on one value

The following code shows how to filter for only the rows where the value in the NSCLC_type column is equal to ‘adenocarcinoma’:
```{r}
adeno_clinical_data <- clinical_data[clinical_data$NSCLC_type == 'adenocarcinoma', ]
adeno_clinical_data
```

To understand how it works, we will decompose the command line:
```{r}
# get the data of the column name "NSCLC_type" of the clinical_data dataset
clinical_data$NSCLC_type
# determine for each value of the previous column if it is 'adenocarcinoma' or not
clinical_data$NSCLC_type == 'adenocarcinoma'
# subset the table where the value of the NSCLC_type column is 'adenocarcinoma' (keep line with TRUE statement)
clinical_data[clinical_data$NSCLC_type == 'adenocarcinoma', ]
```

Best practice: ALWAYS try to check your subset!
```{r}
base::dim(adeno_clinical_data)
base::table(adeno_clinical_data$NSCLC_type)
```
We have 5 lines and 6 columns, we have 5 "adenocarcinoma" values in NSCLC_type columns and only "adenocarcinoma" values. And compared to previously observation of our data we had 5 adenocarcinoma too. So the subset is good!

#### Filter for Rows Based on several values

The following code shows how to filter for only the rows where the value in the NSCLC_type column is equal to ‘adenocarcinoma’ or ‘squamous cell carcinoma’:
```{r}
clinical_data[clinical_data$NSCLC_type == 'adenocarcinoma' | clinical_data$NSCLC_type == 'squamous cell carcinoma', ]
```

Because the `==` allow to test only one value, this method is very limited if we want to write this test for a lot of values. The [`dplyr`](https://dplyr.tidyverse.org/) R package have created the `%in%` operator to compare against a vector of values:

```{r}
clinical_data[clinical_data$NSCLC_type %in% c('adenocarcinoma', 'squamous cell carcinoma'), ]
```

### Filter for Rows Based on multiple Conditions

#### Where multiple Conditions aren't necessarly met (union)

The following code shows how to filter for only the rows where the value in the Age column is more than 65 or less than 60 (union):
```{r}
clinical_data[clinical_data$Age > 65 | clinical_data$Age < 60, ]
```

#### Where multiple Conditions are met (intersection)

The following code shows how to filter for only the rows where the value in the Age column is less than 65 and more than 60 (intersection):
```{r}
clinical_data[clinical_data$Age > 60 & clinical_data$Age < 65, ]
```

The following code shows how to filter for only the rows where the value in the Age column is more than 60, and their NSCLC_type is 'adenocarcinoma' or 'squamous cell carcinoma' (intersection):
```{r}
clinical_data[clinical_data$Age > 60 & clinical_data$NSCLC_type %in% c('adenocarcinoma', 'squamous cell carcinoma'), ]
```

Come back to the problem to subset dataframe columns by their name, with R base.  
Remainder:
```{r, eval = FALSE}
clinical_data[,-"Subject_number"]
clinical_data[,-c("Subject_number","Age")]
```
That doesn't work.  
It is because we have to use logicals to do that.
```{r}
clinical_data[,colnames(clinical_data) != "Subject_number"]
```
That is working!  
Explanation:
```{r}
# get the name of all columns of the dataframe
base::colnames(clinical_data)
# check if the columns names is not "Subject_number"
base::colnames(clinical_data) != "Subject_number"
# then subset the dataframe on columns (be careful to the coma place, here we want to subset columns, not lines)
clinical_data[,base::colnames(clinical_data) != "Subject_number"]
```

Also, we could use the opposite of the positive selection:
```{r}
# subset the dataframe on columns
clinical_data[,!(base::colnames(clinical_data) == "Subject_number")]
```
Explanation:
```{r}
# get the name of all columns of the dataframe
base::colnames(clinical_data)
# check if the columns names is "Subject_number"
base::colnames(clinical_data) == "Subject_number"
# take the opposite
!(base::colnames(clinical_data) == "Subject_number")
# subset the dataframe on columns
clinical_data[,!(base::colnames(clinical_data) == "Subject_number")]
```

Similarly, to exclude several columns:
```{r}
clinical_data[,!(base::colnames(clinical_data) %in% c("Subject_number","Age"))]
```

>Note: `%!in%`, `!%in%` or `%notin%`, don't exist.

## subset()

You can also use the [`subset()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset) function:
```{r}
base::subset(clinical_data, NSCLC_type == 'adenocarcinoma')
base::subset(clinical_data, NSCLC_type %in% c('adenocarcinoma', 'squamous cell carcinoma'))
base::subset(clinical_data, Age > 60 & Age < 65)
base::subset(clinical_data, Age > 60 & NSCLC_type %in% c('adenocarcinoma', 'squamous cell carcinoma'))
```

We can combine the subset of rows and columns.
For example, to retrieve the IDs of patients who have 'adenocarcinoma':
```{r}
base::subset(clinical_data, NSCLC_type == 'adenocarcinoma', select = "Subject_number")
```

## filter() from dplyr

[`dplyr`](https://dplyr.tidyverse.org/) deserves a course on its own because this package allows you to do so many things on tables. It allows us to use the `%in%` operator but also provides many functions.  

>Note: dplyr works on a specific type of table, called `tibble`. When given a dataframe as an argument, it will automatically convert it to a tibble, and the function output can be a tibble.  
>There is no big difference between dataframes and tibbles:  
>- Unlike data frames, tibbles don’t show the entire dataset when you print it.  
>- When you access only one column of a tibble, it will keep the tibble structure. But when you access one column of a data frame, it will become a vector.  
>- Subsetting including [[ ]] and $, work the same for tibbles and data frames.  
>- When assigning a new column to a tibble, the input will not be recycled, which means you have to provide an input of the same length of the other columns. But a data frame will recycle the input.  
>- Tibbles don’t support support arithmetic operations on all columns well, the result will be converted into a data frame without any notice.  
>More information here: https://jtr13.github.io/cc21fall1/tibble-vs.-dataframe.html  

The easiest way to filter is to call dplyr’s [`filter()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/filter) function:
```{r}
library(dplyr)
dplyr::filter(clinical_data, NSCLC_type == 'adenocarcinoma')
```
It is very similar to the [`subset()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset) function.

To filter using a vector for several values:
```{r}
dplyr::filter(clinical_data, NSCLC_type %in% c('adenocarcinoma', 'squamous cell carcinoma'))
```


## Exercise

Calculate the average age of people with an adenocarcinoma.

<details>
<summary>Answer</summary>

```{r}
## with R base
#check if the NSCLC_type is "adenocarcinoma"
clinical_data$NSCLC_type == "adenocarcinoma"
#subset the dataframe to get adenocarcinoma patients
clinical_data[clinical_data$NSCLC_type == "adenocarcinoma",]
#get the age column
clinical_data[clinical_data$NSCLC_type == "adenocarcinoma", "Age"]
#compute the mean
base::mean(clinical_data[clinical_data$NSCLC_type == "adenocarcinoma", "Age"])

## other possible answer with R base
base::mean(clinical_data[clinical_data$NSCLC_type == "adenocarcinoma",]$Age)
base::mean(clinical_data$Age[clinical_data$NSCLC_type == "adenocarcinoma"])

## with subset()
base::mean(base::subset(clinical_data, NSCLC_type == 'adenocarcinoma', select = "Age")$Age)

## with filter()
base::mean(dplyr::filter(clinical_data, NSCLC_type == 'adenocarcinoma')$Age)

```
>Note: [`mean()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/mean) takes a vector, not a dataframe. [`subset()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset) and [`filter()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/filter) output a dataframe, so we have to extract the values of the column for [`mean()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/mean).

In R (and in programming in general), it is possible to obtain results in different ways.

</details>
<br>


## Bonus Tips

### How to know the number of NA value in a column (here named "my_column")
```{r, eval = FALSE}
base::table(is.na(my_df$my_column))
```

### How to remove rows with any zeros
```{r, eval = FALSE}
# Using Base R
my_df_new <- my_df[base::apply(my_df!=0, 1, all),]

# Using dplyr
library(dplyr)
my_df_new <- dplyr::filter_if(my_df, is.numeric, all_vars((.) != 0))
```

### How to remove rows with NA in all Columns
```{r, eval = FALSE}
my_df_new <- my_df[base::rowSums(base::is.na(my_df)) != base::ncol(my_df), ]
```

### How to remove rows with NA in at least One Column
```{r, eval = FALSE}
my_df_new <- my_df[stats::complete.cases(my_df), ]
```

### How to remove duplicated rows
```{r, eval = FALSE}
# Using Base R
my_df_new <- my_df[!base::duplicated(my_df)]
# Using dplyr
library(dplyr)
my_df_new <- my_df %>% dplyr::distinct()
```

### How to remove duplicated rows based on specific column(s)
```{r, eval = FALSE}
library(dplyr)
# On one column named "my_column", with dplyr
my_df_new <- my_df %>% dplyr::distinct(my_column, .keep_all = TRUE)
# On 2 column named "my_column" and "my_awsome_column", with dplyr
my_df_new <- my_df %>% dplyr::distinct(my_column, my_awsome_column, .keep_all = TRUE)
```
> Note: The option .kep_all is used to keep all variables in the data.



# Merging tables

## Add lines to a table

To add a new patient from a vector, we can assign the information of the vector to a new line of our dataframe:
```{r}
# new patient information
new_patient <- c("P0012", 68.7, "adenocarcinoma", "20/01/2018", "yes", "alive")
# get the number of line of our dataframe
base::nrow(clinical_data)
# add patient at the end of the dataframe
clinical_data[base::nrow(clinical_data)+1,] <- new_patient
# check the new number of line of our dataframe
base::nrow(clinical_data)
# print the end of the dataframe to check the addition
utils::tail(clinical_data, 3)
# print the structure of the dataframe to check the classes
utils::str(clinical_data)
# Age is changed to character! convert it to numeric
clinical_data$Age <- base::as.numeric(clinical_data$Age)
```

But if you have several patients to add, it is easier to add them with the [`rbind()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/cbind) function:

```{r}
# new patients to add
new_patients <- base::data.frame(
                    Subject_number = c("P0013", "P0014"),
                    Age = c(58.3, 70),
                    NSCLC_type = c("adenocarcinoma","squamous cell carcinoma"),
                    Date_of_Diagnosis = c("23/06/2014","02/08/2016"),
                    Progression = c("no","yes"),
                    Death_or_alive = c("alive","dead")
                )
new_patients

# add patients in the dataframe
clinical_data <- base::rbind(clinical_data, new_patients)

# check the new number of line of our dataframe
base::nrow(clinical_data)

# print the end of the dataframe to check the addition
utils::tail(clinical_data, 3)
```
Or if you have one patient as a vector:
```{r}
# new patient information
new_patient <- c("P0015", 58.5, "adenocarcinoma", "10/12/2020", "no", "alive")

# add patient at the end of the dataframe
clinical_data <- base::rbind(clinical_data, new_patient)

# check the new number of line of our dataframe
base::nrow(clinical_data)

# print the end of the dataframe to check the addition
utils::tail(clinical_data, 3)

# Age is changed to character! convert it to numeric
clinical_data$Age <- base::as.numeric(clinical_data$Age)
```

## Add columns to a table

You can use columns index or name, to add new column:
```{r}
# new column information
Previous_chemiotherapy_vector <- c("yes","yes","yes","yes","yes","yes","yes","no","yes","no","yes","no","no","yes","yes")

# add column at the end of the dataframe
clinical_data$Previous_chemiotherapy <- Previous_chemiotherapy_vector
head(clinical_data)

```

Be careful, if you add a column with a new index, the column will not get a name. R will add a name by itself, so you have to rename the column.
```{r}
# add new column
Previous_radiotherapy_vector <- c("yes","yes","yes","yes","yes","yes","yes","no","yes","no","yes","no","no","yes","yes")
clinical_data[,base::ncol(clinical_data)+1] <- Previous_radiotherapy_vector
utils::head(clinical_data) # the new column is name V8
# print column names
base::colnames(clinical_data)
# rename the last column
base::colnames(clinical_data)[base::ncol(clinical_data)] <- "Previous_radiotherapy"
# print column names
base::colnames(clinical_data)
```
To change a column name you can use the index as above, but it could easily lead to human error. Change column names with logical indexing is a best practice.
```{r}
base::colnames(clinical_data)[base::colnames(clinical_data) == "V8"] <- "Previous_radiotherapy"
```
Here’s how to read this: “Change the names of clinical_data, but only where the original name was "V8", to "Previous_radiotherapy".

Similar to combine row with [`rbind()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/cbind), we can combine column with [`cbind()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/cbind):
```{r}
Previous_immunotherapy_vector <- c("no","yes","no","no","no","yes","yes","yes","no","no","yes","yes","no","no","yes")
base::cbind(clinical_data, Previous_immunotherapy = Previous_immunotherapy_vector) # the new column is named "Previous_immunotherapy"

```

Be careful!!
[`rbind()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/cbind) and [`cbind()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/cbind) will basically paste rows or columns together. Be sure that the order of your rows or columns is good.


## Add lines and columns to a table

To merge big or complex dataframe, the [`merge()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/merge) function is preferable.

We will work with a complementary table that you can find here: https://github.com/gustaveroussy/training_bigr/blob/main/Tables_manipulation/For_Students/Clinical_Cohort_Complement.csv
```{r}
# read the complementary dataframe
clinical_data_complement <- utils::read.table("Clinical_Cohort_Complement.csv", sep = ",", header = TRUE)
```

As usual, look at the new table:
```{r}
# print first lines
utils::head(clinical_data_complement)
# dimensions
base::dim(clinical_data_complement)
# structure
utils::str(clinical_data_complement)
```

Then, merge dataframes based on specific column:
```{r}
total_clinical_data <- base::merge(x = clinical_data, y = clinical_data_complement, by = "Subject_number")
utils::head(total_clinical_data)
base::dim(total_clinical_data)

```

>Notes:  
- the lines order doesn't matter, merge() combines data based on the values of the designed column.  
- if we want to merge on a column that does not have the same name in the two dataframes, we specify the column names with the arguments `by.x` and `by.y` instead of `by`.  
- if we have columns that have the same name in the 2 dataframes but we do not merge on them, R will add the suffixes ".x" and ".y" to the names of the columns coming from the dataframe at x and y respectively .  
- if lines from one of the 2 dataframes have no equivalent in the other, R does not keep these lines by default. To keep them, you must define the arguments `all.x = TRUE` and `all.y = TRUE`, and `NA` will be printed in columns of these rows with no match.  
- if `by` is not specified, R will take all the column names in common between the 2 dataframes.  
- to merge dataframes on several columns: merge(x, y, by = c("col1","col2")).  


# Operation on tables

## Replace a value by another one

Often we have to change some values, especially when the table was made by several persons and no naming convention was establish.
For example, for "Sex" column we could find "F", "Female" or "female". For R these 3 values are different, but we know as human that they are the same. To tell to R that they are the same, we have to give them exactly the same value.
```{r}
#for values one by one
total_clinical_data$Sex[total_clinical_data$Sex == "Female"] <- "F"
total_clinical_data$Sex[total_clinical_data$Sex == "female"] <- "F"

# for all value
total_clinical_data$Sex[total_clinical_data$Sex %in% c("Female", "female")] <- "F"
```


## Pipes from dplyr

Pipes are use to solve the problem of nested function calls. A nested function occurs whenever the argument of f() is itself a function g(). As you have probably discovered, it is hard to keep the parentheses straight when you write long statements of the form: f(g(x)).
A pipe takes the result of the interior function then pass it along to the exterior function. So f(g(x)) can be rewritten using a pipe: g(x) %>% f. This can be helpful for very long, multi-line statements in R. Just read the pipe operator `%>%` as “THEN”.

To illustrate, start with the total_clinical_data THEN filter it:
```{r}
total_clinical_data %>% dplyr::filter(NSCLC_type == 'adenocarcinoma')
```
To assign the result to a variable (a new dataframe):
```{r}
filtered_clinical_data <- total_clinical_data %>% dplyr::filter(NSCLC_type == 'adenocarcinoma')
```

Of course you can put as much `%>%` as you need in one line.


## Split and merge columns

### split a column into 2
Sometimes we need to split a column into multiple columns depending on a special character (a separator).

For that, the [`stringr`](https://cran.r-project.org/web/packages/stringr/index.html) R package provides useful function to work on strings, especially the [`str_split_fixed`](https://www.rdocumentation.org/packages/stringr/versions/0.6.1/topics/str_split_fixed) function. Initially allow to split a vector, but a column of a dataframe is a vector.

```{r}
total_clinical_data[c('Mutation_Gene', 'Mutation_Type')] <- stringr::str_split_fixed(total_clinical_data$Mutation, '_', 2)
head(total_clinical_data)
```
> Note: the [`str_split_fixed`](https://www.rdocumentation.org/packages/stringr/versions/0.6.1/topics/str_split_fixed) function doesn't automaticcaly remove the original column. We can remove it by `total_clinical_data$Mutation <- NULL`.

We can also use [`tidyr`](https://tidyr.tidyverse.org/), with its [`separate()`](https://www.rdocumentation.org/packages/tidyr/versions/1.3.1/topics/separate) function.

```{r}
library(tidyr)
total_clinical_data <- total_clinical_data %>% tidyr::separate(Mutation, c('Mutation_Gene', 'Mutation_Type'))
head(total_clinical_data)
```

> Note: the [`separate()`](https://www.rdocumentation.org/packages/tidyr/versions/1.3.1/topics/separate) function automaticcaly remove the original column.

### Merge 2 columns into 1

To merge 2 columns into one, you can use the [`paste()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/paste).

For example to retrive the "Mutation" column (previously erased by the [`separate()`](https://www.rdocumentation.org/packages/tidyr/versions/1.3.1/topics/separate) function):
```{r}
total_clinical_data$Mutation <- base::paste(total_clinical_data$Mutation_Gene, total_clinical_data$Mutation_Type, sep = "_")

```


## Sort a dataframe

### order()

To sort a dataframe based on a specific column, you can use the [`order()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/order) function.

```{r}
# sort the Age column in increasing order
base::order(total_clinical_data$Age)

# sort total_clinical_data in increasing order based on Age
total_clinical_data[base::order(total_clinical_data$Age), ]
```

By default, the [`order()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/order) function will sort values in ascending (increasing) order. If you want to order the values in descending (decreasing) order, just add the argument `decreasing = TRUE` to the [`order()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/order) function:

```{r}
total_clinical_data[base::order(total_clinical_data$Age, decreasing = TRUE), ] #decreasing order
```

To order by several columns:
```{r}
total_clinical_data[base::order(total_clinical_data$Sex, total_clinical_data$Age, decreasing = TRUE), ] #decreasing order
```
Here data are first order by Sex then if some values are equal they are sorted by Age.

>Note: you can sort character data too! It will use alphabetical order.

### arrange()

To sort a dataframe based on a specific column, you can use the [`arrange()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/arrange) function from [`dplyr`](https://dplyr.tidyverse.org/) R package.

```{r}
dplyr::arrange(total_clinical_data, Age)
```
Note that [`arrange()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/arrange) always sort the dataframe in increasing order.
To sort in decreasing order, ou have to add the [`desc()`](https://www.rdocumentation.org/packages/plyr/versions/1.8.9/topics/desc) function around the column name:
```{r}
dplyr::arrange(total_clinical_data, desc(Age))
```


## Aggregation

Aggregation allows to apply a function on grouped data by a column.

### aggregate()

The first aggregation function we’ll cover is [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate). Aggregate allows you to easily answer questions in the form: "What is the result of the function applied to a column at each level of one (or more) other column(s) ?"
For example, "What is the mean Age for each Sex?"

If we wanted to answer this question using basic R functions, we’d have to write a separate command for each sex like this:
```{r}
base::mean(total_clinical_data[total_clinical_data$Sex == "F", "Age"])
base::mean(total_clinical_data[total_clinical_data$Sex == "M", "Age"])
```

Here there are only 2 values for Sex, so we can do that like that. But it is very limited if we have a lot of values. For these cases, we can use the [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) function.

```{r}
aggr_res <- stats::aggregate(x = Age ~ Sex,              # Age is the value, Sex is the group 
                             FUN = mean,                 # The function you want to apply (here mean)
                             data = total_clinical_data) # The dataframe
aggr_res
```

As you can see, the [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) function has returned a dataframe with a column for the variable Sex, and a column for the results of the function mean applied to Age at each level of Sex. The result of this function is the same thing we’d got from manually indexing each level of Sex individually – but of course, this code is much simpler and more elegant.

You can also include a subset argument within an [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) function to apply the function to subsets of the original data.
For example, if I wanted to calculate the mean patient Age for each Sex, but only when the patient has an adenocarcinoma, I would do the following:

```{r}
aggr_res <- stats::aggregate(x = Age ~ Sex,                           # Age is the value, Sex is the group 
                             FUN = mean,                              # the function you want to apply (here mean)
                             subset = NSCLC_type == "adenocarcinoma", # only when patient has an adenocarcinoma
                             data = total_clinical_data)              # the dataframe
aggr_res

```

You can also include multiple independent variables in the formula argument to [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate). For example, let’s use [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) to now get the mean Age of the patients for all combinations of both Sex and NSCLC_type, but now only for progressing cancer:

```{r}
aggr_res <- stats::aggregate(x = Age ~ Sex + NSCLC_type,     # Age is the value, Sex and NSCLC_type are the groups
                             FUN = mean,                     # the function you want to apply (here mean)
                             subset = Progression == "yes", # only where cancer is progressing
                             data = total_clinical_data)     # the dataframe
aggr_res

```
>Note: the [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) function can be used like that too:
```{r}
aggregate(x = total_clinical_data$Age,        # Age is the value
          by = list(total_clinical_data$Sex), # Sex is the group 
          FUN = mean)                         # the function you want to apply (here mean)
```

### group_by()

[`group_by()`](https://www.rdocumentation.org/packages/dplyr/versions/1.0.10/topics/group_by) is a function from [`dplyr`](https://dplyr.tidyverse.org/) R package/ that allow to group data, like the right part at the "~" of the [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) function.

For our example, "What is the mean Age for each Sex?"
```{r}
library(dplyr)
grpby_res <- total_clinical_data %>% # the dataframe
  dplyr::group_by(Sex) %>%                  # Sex is the group 
  dplyr::summarise(mean(Age))               # calculate mean on column Age in total_clinical_data
grpby_res
```

Also, we can add a subset step before computation of the mean, with the [`filter()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/filter) function that we saw previously.
For example, if I wanted to calculate the mean patient Age for each Sex, but only when the patient has an adenocarcinoma, I would do the following:

```{r}
grpby_res <- total_clinical_data %>%          # the dataframe
  dplyr::filter(NSCLC_type == "adenocarcinoma") %>%  # only when patient has an adenocarcinoma
  dplyr::group_by(Sex) %>%                           # Sex is the group 
  dplyr::summarise(mean(Age))                        # calculate mean on column Age in total_clinical_data
grpby_res
```

And if we want to group by several columns?

```{r}
grpby_res <- total_clinical_data %>%  # the dataframe
  dplyr::filter(Progression == "yes") %>%    # only where cancer is progressing
  dplyr::group_by(Sex, NSCLC_type) %>%       # Sex and NSCLC_type are the groups
  dplyr::summarise(mean(Age))                # calculate mean on column Age in total_clinical_data
grpby_res
```

But dplyr allows us to go even further!!
We can use several functions easily! 

```{r}
grpby_res <- total_clinical_data %>%         # the dataframe
  dplyr::filter(Progression == "yes") %>%    # only where cancer is progressing
  dplyr::group_by(Sex, NSCLC_type) %>%       # Sex and NSCLC_type are the groups
  dplyr::summarise(
      my_mean_value = mean(Age),             # calculate mean on column Age in total_clinical_data
      my_max = max(Age),                     # calculate maximum on column Age in total_clinical_data
      my_min = min(Age),                     # calculate minimum on column Age in total_clinical_data
      my_frequency = n(),                    # calculate the number of patients in each group
      my_mean_value_sup65 = mean(Age > 65))  # calculate the mean on column Age only if Age > 65 (do a specific subset before computation)
    
grpby_res

```
Note: the [`n()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/n) function is specific to dplyr and returns a frequency of values in a summary command.

Note: we can do that with [`aggregate()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) but it is more complicated, we have to create our own function inside aggregate, so [`dplyr`](https://dplyr.tidyverse.org/) is the easier!

[`dplyr`](https://dplyr.tidyverse.org/) can be a little complex to master because it offers lots of functions (here we only saw [`filter()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/filter), [`group_by()`](https://www.rdocumentation.org/packages/dplyr/versions/1.0.10/topics/group_by), [`summarise()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/summarise), [`n()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/n), but there are many others), but it is its variety of functions and the sequence of these functions that make it a powerful tool.

Cheatsheet about dplyr: https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf


```{r}
# clean all the environment
rm(list = ls())
gc()
```

# Exercise

You will work on VCF files.
The Variant Call Format (or VCF) is a standard text file format used in bioinformatics for storing gene sequence variations. It is a common output format for variant calling programs.
The header begins the file and provides metadata describing the body of the file. Header lines are denoted as starting with #. The header contains keywords that optionally semantically and syntactically describe the fields used in the body of the file, notably INFO, FILTER, and FORMAT.
More information about VCF files here: https://en.wikipedia.org/wiki/Variant_Call_Format

1) Load and see what the provided vcf (https://github.com/gustaveroussy/training_bigr/blob/main/Tables_manipulation/For_Students/Sample1.vcf.gz) named "Sample1.vcf.gz" looks like.

Tips: if you don't have columns name you can set them. They are "CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT" and "SAMPLE_INFO", in this order.
<details>
<summary>Answer</summary>
```{r}
# read data
vcf1 <- utils::read.table(
    file = base::gzfile("Sample1.vcf.gz"),
    header = FALSE,
    sep = "\t"
)
# print first lines
utils::head(vcf1)
# dimensions
base::dim(vcf1)
# structure
utils::str(vcf1)
# add column names
base::colnames(vcf1) <- c("CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO","FORMAT","SAMPLE_INFO")
utils::head(vcf1)

```

> Note: by default read.table() ignore lines which begins by `#`. So it doesn't load the comments.

</details>
<br>

2) Load and see what the provided vcf (https://github.com/gustaveroussy/training_bigr/blob/main/Tables_manipulation/For_Students/Sample2.vcf.gz) named "Sample2.vcf.gz" looks like, then assemble the 2 VCF files into one. Remember to keep the original patient information for each mutation.

<details>
<summary>Answer</summary>
```{r}
# read data
vcf2 <- utils::read.table(
    file = base::gzfile("Sample2.vcf.gz"),
    header = FALSE,
    sep = "\t"
)
# print first lines
utils::head(vcf2)
# dimensions
base::dim(vcf2)
# structure
utils::str(vcf2)
# add column names
base::colnames(vcf2) <- c("CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO","FORMAT","SAMPLE_INFO")
utils::head(vcf2)

# add SAMPLE_NAME column to keep this information (here I use the recycling feature of R to duplicated the name of the sample as long as the number of mutations)
vcf1$SAMPLE_NAME <- c("Sample1")
vcf2$SAMPLE_NAME <- c("Sample2")

# merge vcf
vcf <- base::rbind(vcf1,vcf2)

```
</details>
<br>

3) Filter to keep only "PASS" mutations of "FILTER" column, and check the number of unique variants lost with this filter. A variant is defined by the total position of the variant ("CHROM" and "POS") and the base modification ("REF" and "ALT").

<details>
<summary>Answer</summary>
```{r}
# number of unique variants before filtering
nb_before_filtering <- vcf[,c("CHROM","POS","REF","ALT")] %>% dplyr::distinct() %>% base::nrow()
# filtering
PASS_vcf <- base::subset(vcf, FILTER == "PASS")
# number of unique variants after filtering
nb_after_filtering <- PASS_vcf[,c("CHROM","POS","REF","ALT")] %>% dplyr::distinct() %>% base::nrow()
# get number of unique variants lost with this filter
nb_lost <- nb_before_filtering - nb_after_filtering
nb_lost
```
</details>
<br>

4) What is the number of “PASS” variants in the X chromosome in patient Sample2.

<details>
<summary>Answer</summary>
```{r}
#get variants from the chromosome X in the patient Sample2
X_Sample2_vcf <- base::subset(PASS_vcf, CHROM == "X" & SAMPLE_NAME == "Sample2")
# get the number of variants
base::nrow(X_Sample2_vcf)

```
</details>
<br>


5) What is the number of “PASS” variants that are present in the 2 patients? A variant is defined by the total position of the variant ("CHROM" and "POS") and the base modification ("REF" and "ALT").

<details>
<summary>Answer</summary>
```{r}
#paste variants information like ID
vector_PASS_variant <- base::paste(PASS_vcf$CHROM,PASS_vcf$POS,PASS_vcf$REF,PASS_vcf$ALT, sep = "_")
#get occurrences
occurrence_PASS_variant <- base::table(vector_PASS_variant)
#get variants where occurrence is 2
occurrenceis2_PASS_variant <- base::names(occurrence_PASS_variant)[occurrence_PASS_variant == 2]
# get number of variants where occurrence is 2
base::length(occurrenceis2_PASS_variant)

```
Another way to do it with dplyr:
```{r}
# filtering, make variants thanks to their characteristics, and get occurrences
occurrence_PASS_variant <- PASS_vcf %>%
                           dplyr::group_by(CHROM, POS, REF, ALT) %>%
                           dplyr::summarise(frequency = n())

#get variants where occurrence is 2
occurrenceis2_PASS_variant <- occurrence_PASS_variant[occurrence_PASS_variant$frequency == 2,]

# get number of variants where occurrence is 2
base::nrow(occurrenceis2_PASS_variant)

```

</details>
<br>


To go further:  
https://bookdown.org/ndphillips/YaRrr/  
https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf  

